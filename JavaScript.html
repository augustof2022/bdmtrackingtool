<script>
  // --- STATE MANAGEMENT ---
const state = {
    currentUser: null,
    dropdownOptions: {},
    currentView: 'login-view',
    searchResults: [],
    mySubmissions: [], // To hold data for the "My Submissions" tab
    pendingPromises: {} // To manage async operations
  };

  // --- DOM ELEMENTS ---
  const loader = document.getElementById('loader');
  const views = document.querySelectorAll('.view');
  const loginMessage = document.getElementById('login-message');
  const registerMessage = document.getElementById('register-message');
  const adminControls = document.getElementById('admin-controls');  

  // --- APP INITIALIZATION ---
  document.addEventListener('DOMContentLoaded', () => {
    // Attach initial event listeners
    document.getElementById('login-form').addEventListener('submit', handleLogin);
    document.getElementById('register-form').addEventListener('submit', handleRegistration);
    document.getElementById('logout-btn').addEventListener('click', handleLogout);

    document.getElementById('show-register-link').addEventListener('click', (e) => { e.preventDefault(); switchView('register-view'); });
    document.getElementById('show-login-link').addEventListener('click', (e) => { e.preventDefault(); switchView('login-view'); });

    // Batch creation listeners
    document.getElementById('add-row-btn').addEventListener('click', addTransactionRow);
    document.getElementById('submit-batch-btn').addEventListener('click', handleSubmitBatch);

    // Tab navigation listener (targets all tab navigations)
    document.querySelectorAll('.tab-nav').forEach(nav => nav.addEventListener('click', handleTabSwitch));
    
    // On-demand fetch and other delegated listeners
    document.body.addEventListener('click', function(e) {
      if (e.target && e.target.id === 'fetch-submissions-btn') {
        loadMySubmissions();
      }
      if (e.target && e.target.id === 'fetch-pending-directives-btn') {
        fetchAndRenderDirectives({ type: 'pending' });
      }
    });

    // Delegated event listener for actions in the "My Submissions" table
    // Delegated event listeners for dynamic content
    document.getElementById('cl-submitted-container').addEventListener('click', handleMySubmissionsActions);
    document.getElementById('directive-creator-container').addEventListener('click', handleDirectiveCreatorActions);
    document.getElementById('directive-list-results').addEventListener('click', handleDirectiveListActions);

    // Search and navigation
    document.getElementById('cl-search-form').addEventListener('submit', handleSearch);
    document.getElementById('bdm-search-form').addEventListener('submit', handleSearch);
    document.getElementById('directive-search-form').addEventListener('submit', handleDirectiveSearch);
    document.getElementById('back-to-home-btn').addEventListener('click', () => {
      // Use the robust viewType to determine the correct home view
      const homeView = (state.currentUser.viewType === 'CL_view') ? 'cl-home-view' : 'bdm-home-view';
      switchView(homeView);
    });

    // Admin and Modal listeners
    document.getElementById('manage-users-btn').addEventListener('click', openUserApprovalModal);
    document.getElementById('admin-view-switcher').addEventListener('change', handleAdminViewSwitch);
    document.getElementById('modal-close-btn').addEventListener('click', closeUserApprovalModal);
    document.getElementById('batch-success-close-btn').addEventListener('click', closeBatchSuccessModal);

    // Pre-fetch dropdown options as soon as the app loads
    // We store the promise to ensure we can wait for it later
    state.pendingPromises.dropdowns = new Promise((resolve, reject) => {
      google.script.run
        .withSuccessHandler(options => {
          state.dropdownOptions = options;
          // Populate the registration role dropdown
          const roleSelect = document.getElementById('reg-role');
          if (roleSelect) {
            // Add a placeholder first
            roleSelect.innerHTML = '<option value="" disabled selected>-- Select a Role --</option>';
            roleSelect.innerHTML += generateSelectOptions(options.roleOptions, null, false);
          }
          resolve();
        })
        .withFailureHandler(err => {
          handleError(err);
          reject(err);
        })
        .getDropdownOptions();
    });
  });

  // --- VIEW & LOADER UTILS ---
  function showLoader(show) {
    loader.style.display = show ? 'flex' : 'none';
  }

  function switchView(viewId) {
    const allKnownViews = [
      'login-view', 'register-view', 'app-container',
      'cl-home-view', 'bdm-home-view', 'search-results-view'
    ];
    const subViews = ['cl-home-view', 'bdm-home-view', 'search-results-view'];

    allKnownViews.forEach(id => {
      const element = document.getElementById(id);
      if (element) { element.style.display = 'none'; }
    });

    const targetViewElement = document.getElementById(viewId);
    if (targetViewElement) {
      if (subViews.includes(viewId)) {
        document.getElementById('app-container').style.display = 'block';
        targetViewElement.style.display = 'block';
      } else {
        targetViewElement.style.display = 'flex';
      }
    }
    
    // If switching to the CL view, initialize the batch creator
    if (viewId === 'cl-home-view') {
        initializeBatchCreator();
    }
    state.currentView = viewId;
  }

  function handleError(error) {
    console.error('An error occurred:', error);
    alert('An error occurred: ' + error.message);
    showLoader(false);
  }

  // --- NEW HELPER FUNCTION for auto-resizing textareas ---
  /**
   * Adjusts the height of a textarea element to fit its content.
   * @param {HTMLTextAreaElement} textarea The textarea to resize.
   */
  function autoResizeTextarea(textarea) {
    if (!textarea || typeof textarea.style === 'undefined') return;
    textarea.style.height = 'auto'; // Temporarily shrink to get the correct scrollHeight
    textarea.style.height = (textarea.scrollHeight) + 'px';
  }

  // --- AUTHENTICATION HANDLERS ---
  function handleLogin(event) {
    event.preventDefault();
    showLoader(true);
    const email = document.getElementById('email').value;
    const password = document.getElementById('password').value;
    loginMessage.textContent = '';
    loginMessage.className = 'message-text';

    google.script.run
      .withSuccessHandler(result => {
        if (result.status === 'SUCCESS') {
          state.currentUser = result.user;
          // Wait for dropdowns to be loaded before proceeding
          state.pendingPromises.dropdowns.then(() => {
            showLoader(false);
            document.getElementById('user-details').textContent = `Welcome, ${result.user.fullName}`;
            
            let targetView = '';
            const viewType = result.user.viewType;

            // --- NEW VIEW LOGIC ---
            if (viewType === 'Admin_view') {
              targetView = 'bdm-home-view'; // Admin defaults to BDM view
              adminControls.style.display = 'flex'; // Show admin controls
            } else if (viewType === 'CL_view') {
              targetView = 'cl-home-view';
              adminControls.style.display = 'none'; // Hide admin controls
            } else { // Includes BDM_view and any other defaults
              targetView = 'bdm-home-view';
              adminControls.style.display = 'none'; // Hide admin controls
            }
            
            if (targetView) {
              switchView(targetView);
            } else {
              handleError(new Error('Could not determine a view for your user role.'));
            }
          }).catch(err => {
            showLoader(false);
            handleError(new Error("Could not load required app data. Please refresh."));
          });

        } else {
          showLoader(false);
          if (result.status === 'PENDING_APPROVAL') {
            loginMessage.textContent = 'Your account is pending approval.';
          } else {
            loginMessage.textContent = 'Invalid email or password.';
          }
        }
      })
      .withFailureHandler(err => {
        handleError(err);
        loginMessage.textContent = 'An error occurred during login.';
      })
      .verifyUser(email, password);
  }

  function handleRegistration(event) {
    event.preventDefault();
    const fullName = document.getElementById('reg-fullname').value;
    const areaName = document.getElementById('reg-area').value;
    const email = document.getElementById('reg-email').value;
    const password = document.getElementById('reg-password').value;
    const confirmPassword = document.getElementById('reg-confirm-password').value;
    const role = document.getElementById('reg-role').value; // Get selected role

    registerMessage.textContent = '';

    if (password !== confirmPassword) {
      registerMessage.textContent = 'Passwords do not match.';
      return;
    }
    if (!role) {
      registerMessage.textContent = 'Please select a role.';
      return;
    }
    
    showLoader(true);
    const userData = { fullName, areaName, email, password, role }; // Add role to data
    google.script.run
      .withSuccessHandler(response => {
        showLoader(false);
        if (response.success) {
          registerMessage.textContent = response.message;
          document.getElementById('register-form').reset();
          setTimeout(() => switchView('login-view'), 3000);
        } else {
          registerMessage.textContent = response.message;
        }
      })
      .withFailureHandler(handleError)
      .createNewUser(userData);
  }

  function handleLogout() {
    state.currentUser = null;
    document.getElementById('login-form').reset();
    document.getElementById('register-form').reset();
    loginMessage.textContent = '';
    registerMessage.textContent = '';
    switchView('login-view');
  }

  // --- TRANSACTION FORM ---
  // --- BATCH TRANSACTION CREATION ---

  function initializeBatchCreator() {
    // First, check if user is eligible to create a batch
    if (!state.currentUser || !state.currentUser.userCode) {
      const creatorDiv = document.getElementById('batch-transaction-creator');
      const batchDisplay = document.getElementById('batch-id-display');
      batchDisplay.textContent = 'N/A';
      creatorDiv.innerHTML = '<p class="error-message">Your account does not have a User Code assigned. You cannot create batches. Please contact an administrator.</p>';
      return;
    }

    showLoader(true);
    google.script.run
      .withSuccessHandler(batchId => {
        showLoader(false);
        document.getElementById('batch-id-display').textContent = batchId;
        document.getElementById('transaction-table-body').innerHTML = '';
        // Restore creator HTML if it was replaced by an error message
        document.getElementById('batch-transaction-creator').innerHTML = `
          <div class="table-wrapper">
            <table id="transaction-table">
              <thead>
                <tr>
                  <th>Action</th>
                  <th>Transaction ID</th>
                  <th>HH ID</th>
                  <th>Grantee Name</th>
                  <th>Entry ID No.</th>
                  <th>Member Name</th>
                  <th>Update Type</th>
                  <th>New Value</th>
                  <th>Req. Status</th>
                  <th>Attachments</th>
                  <th>Validation</th>
                  <th>Recommendation</th>
                </tr>
              </thead>
              <tbody id="transaction-table-body"></tbody>
            </table>
          </div>
          <div class="batch-actions">
            <button id="add-row-btn" class="btn btn-secondary">Add Row</button>
            <button id="submit-batch-btn" class="btn btn-primary">Submit Batch</button>
          </div>
        `;
        // Re-attach listeners for the new buttons
        document.getElementById('add-row-btn').addEventListener('click', addTransactionRow);
        document.getElementById('submit-batch-btn').addEventListener('click', handleSubmitBatch);

        addTransactionRow();
        makeTableResizable(document.getElementById('transaction-table'));
      })
      .withFailureHandler(err => {
        showLoader(false);
        handleError(err);
        document.getElementById('batch-id-display').textContent = 'Error Generating ID';
      })
      .generateNewBatchNo(state.currentUser);
  }

  function addTransactionRow() {
    const tableBody = document.getElementById('transaction-table-body');
    const newRow = tableBody.insertRow();
    const batchNo = document.getElementById('batch-id-display').textContent;
    
    // The sequence is the new number of rows (1-based)
    const sequence = (tableBody.rows.length).toString().padStart(2, '0');
    const transactionId = `${batchNo}-${sequence}`;

    // Generate options for the Update Type dropdown from our new data structure
    const updateTypeOptions = state.dropdownOptions.updateTypeTemplates.map(t => t.updateType);

    newRow.innerHTML = `
      <td><button class="remove-row-btn" onclick="removeTransactionRow(this)">-</button></td>
      <td><input type="text" class="transaction-id" value="${transactionId}" readonly></td>
      <td><div class="input-with-icon">
          <input type="text" class="hh-id" placeholder="Enter HH ID">
          <svg class="duplicate-icon hh-duplicate" viewBox="0 0 24 24" fill="currentColor"><path d="M16 1H4C2.9 1 2 1.9 2 3V17H4V3H16V1ZM20 5H8C6.9 5 6 5.9 6 7V21C6 22.1 6.9 23 8 23H20C21.1 23 22 22.1 22 21V7C22 5.9 21.1 5 20 5ZM20 21H8V7H20V21Z"/></svg>
      </div></td>
      <td><input type="text" class="grantee-name" readonly placeholder="Auto-filled"></td>
      <td><input type="text" class="entry-id" readonly placeholder="Auto-filled"></td>
      <td><div class="input-with-icon">
          <select class="member-name" disabled><option value="">-- Enter HH ID First --</option></select>
          <svg class="duplicate-icon member-duplicate" viewBox="0 0 24 24" fill="currentColor"><path d="M16 1H4C2.9 1 2 1.9 2 3V17H4V3H16V1ZM20 5H8C6.9 5 6 5.9 6 7V21C6 22.1 6.9 23 8 23H20C21.1 23 22 22.1 22 21V7C22 5.9 21.1 5 20 5ZM20 21H8V7H20V21Z"/></svg>
      </div></td>
      <td><select class="update-type">${generateSelectOptions(updateTypeOptions)}</select></td>
      <td><textarea class="new-value" rows="1" placeholder="Auto-filled from Update Type"></textarea></td>
      <td><select class="req-status">${generateSelectOptions(['Complete', 'Incomplete', 'N/A'])}</select></td>
      <td><textarea class="attachments" rows="1" placeholder="List of attached documents and Document link or photo scanned links"></textarea></td>
      <td><textarea class="validation" rows="1" placeholder="Input Validation"></textarea></td>
      <td><textarea class="recommendation" rows="1" placeholder="Input recommendation"></textarea></td>
    `;

    // Add event listeners for the new workflow
    newRow.querySelector('.hh-id').addEventListener('blur', handleHhIdBlurForRow);
    newRow.querySelector('.member-name').addEventListener('change', handleMemberSelection);
    newRow.querySelector('.hh-duplicate').addEventListener('click', duplicateRowByHousehold);
    newRow.querySelector('.member-duplicate').addEventListener('click', duplicateRowByMember);
    // NEW: Add listener for update type change
    newRow.querySelector('.update-type').addEventListener('change', handleUpdateTypeChange);
    // Auto-resize textareas in the new row
    const textareas = newRow.querySelectorAll('textarea');
    textareas.forEach(textarea => {
      textarea.addEventListener('input', () => autoResizeTextarea(textarea));
      autoResizeTextarea(textarea); // Set initial size
    });
  }

  function removeTransactionRow(button) {
    const rowToRemove = button.closest('tr');
    const tableBody = rowToRemove.parentNode;
    rowToRemove.remove();

    // After removing, re-index all remaining rows
    const batchNo = document.getElementById('batch-id-display').textContent;
    const allRows = tableBody.querySelectorAll('tr');
    allRows.forEach((row, index) => {
      const sequence = (index + 1).toString().padStart(2, '0');
      const newTransactionId = `${batchNo}-${sequence}`;
      row.querySelector('.transaction-id').value = newTransactionId;
    });
  }

  function handleHhIdBlurForRow(event) {
    const hhIdInput = event.target;
    const row = hhIdInput.closest('tr');
    const granteeNameInput = row.querySelector('.grantee-name');
    const entryIdInput = row.querySelector('.entry-id');
    const memberNameSelect = row.querySelector('.member-name');
    const hhId = hhIdInput.value;

    // Reset fields
    granteeNameInput.value = '';
    entryIdInput.value = '';
    memberNameSelect.innerHTML = '<option value="">-- Loading --</option>';
    memberNameSelect.disabled = true;
    delete row.dataset.householdData;

    if (hhId) {
      google.script.run
        .withSuccessHandler(data => {
          if (data && data.members && data.members.length > 0) {
            // Store the data on the row for later use
            row.dataset.householdData = JSON.stringify(data.members);
            
            granteeNameInput.value = data.granteeName || 'N/A';
            
            // Populate the member dropdown
            memberNameSelect.innerHTML = ''; // Clear loading message
            let optionsHtml = '<option value="" disabled selected>-- Please Select --</option>';
            data.members.forEach(member => {
              optionsHtml += `<option value="${member.memberName}">${member.memberName}</option>`;
            });
            memberNameSelect.innerHTML = optionsHtml;
            memberNameSelect.disabled = false;
          } else {
            granteeNameInput.value = 'HH ID Not Found';
            memberNameSelect.innerHTML = '<option value="">-- No Members Found --</option>';
          }
        })
        .withFailureHandler(err => {
          granteeNameInput.value = 'Error';
          memberNameSelect.innerHTML = '<option value="">-- Error --</option>';
          handleError(err);
        })
        .getHouseholdData(hhId);
    } else {
      memberNameSelect.innerHTML = '<option value="">-- Enter HH ID First --</option>';
    }
  }

  function handleMemberSelection(event) {
    const select = event.target;
    const row = select.closest('tr');
    const selectedMemberName = select.value;
    const entryIdInput = row.querySelector('.entry-id');

    const membersData = JSON.parse(row.dataset.householdData || '[]');
    const selectedMember = membersData.find(m => m.memberName === selectedMemberName);

    if (selectedMember) {
      entryIdInput.value = selectedMember.entryId;
    } else {
      entryIdInput.value = '';
    }
  }

  function handleUpdateTypeChange(event) {
    const select = event.target;
    const row = select.closest('tr');
    const selectedType = select.value;

    const newValueEl = row.querySelector('.new-value');

    // Find the template object from our state
    const template = state.dropdownOptions.updateTypeTemplates.find(t => t.updateType === selectedType);

    if (template) {
      // The old fields are gone, but we still populate the new value if there's a template for it.
      newValueEl.value = template.newValueTemplate || '';
    } else {
      // Clear fields if no template is found (e.g., placeholder selected)
      newValueEl.value = '';
    }

    // Programmatically dispatch an 'input' event to trigger auto-resizing.
    setTimeout(() => {
        const inputEvent = new Event('input', { bubbles: true });
        newValueEl.dispatchEvent(inputEvent);
    }, 0);
  }

  function handleSubmitBatch() {
    const batchNo = document.getElementById('batch-id-display').textContent;
    const tableBody = document.getElementById('transaction-table-body');
    const rows = tableBody.querySelectorAll('tr');
    const transactions = [];

    if (rows.length === 0) {
      alert('Please add at least one transaction row.');
      return;
    }

    let isValid = true;
    rows.forEach((row, index) => {
      row.style.backgroundColor = ''; // Reset row color
      const transaction = {
        transactionId: row.querySelector('.transaction-id').value,
        hhId: row.querySelector('.hh-id').value,
        granteeName: row.querySelector('.grantee-name').value,
        entryId: row.querySelector('.entry-id').value,
        memberName: row.querySelector('.member-name').value,
        updateType: row.querySelector('.update-type').value,
        newValue: row.querySelector('.new-value').value,
        requirementsStatus: row.querySelector('.req-status').value,
        attachments: row.querySelector('.attachments').value,
        validation: row.querySelector('.validation').value,
        recommendation: row.querySelector('.recommendation').value
      };

      // Basic validation: Check for HH ID, selected member, and a selected update type.
      if (!transaction.hhId || !transaction.updateType || !transaction.memberName || transaction.granteeName === 'HH ID Not Found') {
        isValid = false;
        row.style.backgroundColor = '#f9dada'; // Highlight invalid rows
      }
      transactions.push(transaction);
    });

    if (!isValid) {
      alert('Please fill out all required fields in the highlighted rows. This includes selecting an Update Type.');
      return;
    }

    showLoader(true);
    const batchData = { batchNo, transactions };
    
    google.script.run
      .withSuccessHandler(returnedBatchNo => {
        showLoader(false);
        // Instead of an alert, open our new custom modal.
        openBatchSuccessModal(returnedBatchNo);
        // The form reset (initializeBatchCreator) is now handled by closeBatchSuccessModal.
      })
      .withFailureHandler(handleError)
      .createTransactionsBatch(batchData, state.currentUser);
  }

  function openBatchSuccessModal(batchNo) {
    document.getElementById('modal-batch-no-display').textContent = batchNo;
    document.getElementById('batch-success-modal').style.display = 'flex';
  }

  function closeBatchSuccessModal() {
    document.getElementById('batch-success-modal').style.display = 'none';
    // Reset the form for a new batch after the user has acknowledged the success message.
    initializeBatchCreator();
  }

  // --- SEARCH ---
  function handleSearch(event) {
    event.preventDefault();
    const form = event.target;
    const input = form.querySelector('input[type="search"]');

    if (!input) {
      handleError(new Error("Search input field could not be found in the form."));
      return;
    }
    const query = input.value;
    if (!query) {
      return;
    }
    
    showLoader(true);

    google.script.run
      .withSuccessHandler(results => {
        showLoader(false);
        state.searchResults = results;
        
        // --- THIS IS THE FIX ---
        // Use the new viewType to correctly route the search results.
        const viewType = state.currentUser.viewType;
        if (viewType === 'Admin_view' || viewType === 'BDM_view') {
          renderSearchResults(results); // Render for BDM/Admin
          switchView('search-results-view');
        } else {
          renderClSearchResults(results); // Render for CL
        }
      })
      .withFailureHandler(handleError)
      .searchTransactions(query);
  }

function renderSearchResults(results) {
    // This function handles the BDM and Admin search results view
    const container = document.getElementById('results-table-container');
    if (!results || results.length === 0) {
      container.innerHTML = '<p>No results found.</p>';
      return;
    }

    const displayHeaders = [
        'BATCH_NO', 'TRANSACTION_ID', 'DATE_SUBMITTED', 'SUBMITTED_BY', 'HH_ID_NO',
        'GRANTEE_NAME', 'ENTRY_ID_NO', 'MEMBER_NAME', 'CASE_MANAGER', 'UPDATE_TYPE',
        'REQUIREMENTS_STATUS', 'NEW_VALUE', 'ATTACHMENTS', 'VALIDATION', 'RECOMMENDATION'
    ];
    
    const actionHeaders = [
        'CURRENT_STATUS', 'REMARKS', 'STATUS_CHANGED_BY', 'DATE_STATUS_CHANGED', 'ACTION'
    ];

    let tableHtml = '<table class="results-table"><thead><tr>';
    
    [...displayHeaders, ...actionHeaders].forEach(header => {
      const formattedHeader = header.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
      tableHtml += `<th>${formattedHeader}</th>`;
    });
    tableHtml += '</tr></thead><tbody>';

    results.forEach(row => {
      tableHtml += `<tr 
                      data-transaction-id="${row.TRANSACTION_ID}" 
                      data-initial-status="${row.CURRENT_STATUS}"
                      data-initial-remarks="${row.REMARKS || ''}"
                    >`;

      displayHeaders.forEach(header => {
        const value = row[header];
        let displayValue = (value === null || value === undefined) ? '' : value;
        if (header.toLowerCase().includes('date') && displayValue) {
            const d = new Date(displayValue);
            if (!isNaN(d.getTime())) displayValue = d.toLocaleString();
        }
        tableHtml += `<td>${displayValue}</td>`;
      });
      
      const formattedDateStatusChanged = row.DATE_STATUS_CHANGED ? new Date(row.DATE_STATUS_CHANGED).toLocaleString() : '';
      
      tableHtml += `
        <td><select class="status-dropdown">${generateSelectOptions(state.dropdownOptions.statusOptions, row.CURRENT_STATUS, false)}</select></td>
        <td><textarea class="remarks-input" rows="1">${row.REMARKS || ''}</textarea></td>
        <td>${row.STATUS_CHANGED_BY || ''}</td>
        <td>${formattedDateStatusChanged}</td>
        <td><button class="btn btn-primary save-status-btn" disabled>Save</button></td>
      `;

      tableHtml += '</tr>';
    });

    container.innerHTML = tableHtml + '</tbody></table>';

    // Activate interactive elements after rendering
    container.querySelectorAll('.results-table tbody tr').forEach(row => {
      const statusDropdown = row.querySelector('.status-dropdown');
      const remarksInput = row.querySelector('.remarks-input');
      
      statusDropdown.addEventListener('change', () => toggleSaveButtonState(row));
      remarksInput.addEventListener('input', () => {
        toggleSaveButtonState(row);
        autoResizeTextarea(remarksInput); // Resize as user types
      });
      
      row.querySelector('.save-status-btn').addEventListener('click', handleStatusSave);
    });

    // --- THIS IS THE FIX ---
    // Wait for the browser to render the new table, then resize all textareas.
    setTimeout(() => {
      container.querySelectorAll('textarea.remarks-input').forEach(textarea => {
          autoResizeTextarea(textarea);
      });
    }, 0);
    
    // Make the newly rendered BDM results table resizable
    const table = container.querySelector('.results-table');
    if (table) {
      makeTableResizable(table);
    }
}

function handleStatusSave(event) {
    const row = event.target.closest('tr');
    const button = event.target;
    const transactionId = row.dataset.transactionId;
    
    // Get initial state from data attributes
    const initialStatus = row.dataset.initialStatus;

    // Get current state from inputs
    const newStatus = row.querySelector('.status-dropdown').value;
    const newRemarks = row.querySelector('.remarks-input').value;

    const statusChanged = newStatus !== initialStatus;

    // --- VALIDATION LOGIC ---
    if (!statusChanged && newRemarks !== row.dataset.initialRemarks) {
      alert('A status change is required when adding or editing remarks. Please select a new status.');
      return;
    }

    if (!statusChanged && newRemarks === row.dataset.initialRemarks) {
      alert('No changes to save.');
      return;
    }
    
    showLoader(true);
    button.disabled = true; 
    button.textContent = 'Saving...';

    google.script.run
      .withSuccessHandler(response => {
         showLoader(false); 
         alert(response.message);
         
         if (response.success) {
            // Update the row's state on the frontend to match the new reality
            row.dataset.initialStatus = newStatus;
            row.dataset.initialRemarks = newRemarks;
            
            // --- VISUAL FEEDBACK FOR SUCCESS ---
            button.textContent = 'Saved!';
            button.classList.remove('btn-actionable');
            button.classList.add('btn-success'); // Make it green

            // Re-run the state check. This will now see no changes and disable the button,
            // but the logic will leave the green 'btn-success' class.
            toggleSaveButtonState(row);

         } else {
            // If the server rejects the save, revert to the "actionable" state
            button.disabled = false;
            button.textContent = 'Save';
            button.classList.add('btn-actionable');
         }
      })
      .withFailureHandler(err => { 
        handleError(err); 
        button.disabled = false; 
        button.textContent = 'Save'; 
        button.classList.add('btn-actionable');
      })
      .updateTransactionStatus(transactionId, newStatus, newRemarks, state.currentUser);
  }

  /**
   * Enables or disables the save button for a row based on whether its
   * status or remarks have changed from their initial values. Also manages button color.
   * @param {HTMLTableRowElement} row The table row to check.
   */
  function toggleSaveButtonState(row) {
    const initialStatus = row.dataset.initialStatus;
    const initialRemarks = row.dataset.initialRemarks;

    const currentStatus = row.querySelector('.status-dropdown').value;
    const currentRemarks = row.querySelector('.remarks-input').value;
    const saveButton = row.querySelector('.save-status-btn');

    const hasChanged = (currentStatus !== initialStatus) || (currentRemarks !== initialRemarks);
    
    if (hasChanged) {
        saveButton.disabled = false;
        saveButton.classList.remove('btn-success'); // Remove green if present
        saveButton.classList.add('btn-actionable');  // Add red to show pending change
    } else {
        saveButton.disabled = true;
        saveButton.classList.remove('btn-actionable'); // Remove red if present
        // We intentionally do NOT remove btn-success here, so it persists after a save.
    }
  }

  // --- HELPERS ---
function generateSelectOptions(options, selectedValue, includePlaceholder = true) {
    if (!Array.isArray(options)) return '';

    // Create a mutable copy of the options to avoid changing the global state
    let availableOptions = [...options];

    // --- THIS IS THE FIX for the display issue ---
    // If the transaction's current status (selectedValue) is not in the list of
    // selectable options for the user, add it to the beginning of the list for this
    // specific dropdown so it displays correctly.
    if (selectedValue && !availableOptions.includes(selectedValue)) {
      availableOptions.unshift(selectedValue);
    }

    const placeholder = includePlaceholder
      ? `<option value="" disabled ${!selectedValue ? 'selected' : ''}>-- Select Status --</option>`
      : '';

    const optionElements = availableOptions.map(opt =>
      `<option value="${opt}" ${opt === selectedValue ? 'selected' : ''}>${opt}</option>`
    ).join('');

    return placeholder + optionElements;
  }

  // --- ADMIN FUNCTIONS ---

  function handleAdminViewSwitch(event) {
    const selectedView = event.target.value;
    switchView(selectedView);
  }

  function openUserApprovalModal() {
    showLoader(true);
    google.script.run
      .withSuccessHandler(users => {
        showLoader(false);
        renderUsersForApproval(users);
        document.getElementById('user-approval-modal').style.display = 'flex';
      })
      .withFailureHandler(handleError)
      .getUsersForAdmin(state.currentUser);
  }

  function closeUserApprovalModal() {
    document.getElementById('user-approval-modal').style.display = 'none';
    document.getElementById('user-list-container').innerHTML = ''; // Clear content
  }

  function renderUsersForApproval(users) {
    const container = document.getElementById('user-list-container');
    if (!users || users.length === 0) {
      container.innerHTML = '<p>No users found.</p>';
      return;
    }

    let tableHtml = '<table class="results-table"><thead><tr><th>Full Name</th><th>Email</th><th>User Code</th><th>Status</th><th>Action</th></tr></thead><tbody>';

    users.forEach(user => {
      let statusControl = `<span>${user.approvalStatus}</span>`;
      if (user.approvalStatus === 'Pending') {
        statusControl = `<select class="user-status-select">
                           <option value="Pending" selected>Pending</option>
                           <option value="Approved">Approve</option>
                           <option value="Rejected">Reject</option>
                         </select>`;
      }

      tableHtml += `<tr data-user-email="${user.email}">
        <td>${user.fullName}</td>
        <td>${user.email}</td>
        <td><input type="text" class="user-code-input" value="${user.userCode || ''}" placeholder="e.g., JDC" style="width: 100px;"></td>
        <td class="status-cell">${statusControl}</td>
        <td class="action-cell">
          <button class="btn btn-primary save-user-details-btn">Save</button>
        </td>
      </tr>`;
    });

    container.innerHTML = tableHtml + '</tbody></table>';

    // Add event listeners to all the new "Save" buttons
    document.querySelectorAll('.save-user-details-btn').forEach(btn => {
      btn.addEventListener('click', handleUserDetailUpdate);
    });
  }

  function handleUserDetailUpdate(event) {
    const button = event.target;
    const row = button.closest('tr');
    const userEmail = row.dataset.userEmail;
    
    const statusSelect = row.querySelector('.user-status-select');
    const codeInput = row.querySelector('.user-code-input');

    const details = {
      userCode: codeInput.value.trim().toUpperCase()
    };
    
    // Only include status if the dropdown exists (i.e., for pending users)
    if (statusSelect) {
      details.newStatus = statusSelect.value;
      if (details.newStatus === 'Pending') {
        // If they are just saving the code without changing status, that's fine.
        // We will just not send the 'newStatus' field.
        delete details.newStatus;
      }
    }

    if (details.userCode && details.userCode.length !== 3) {
      alert('User Code must be exactly 3 characters long.');
      return;
    }

    showLoader(true);
    button.disabled = true;
    button.textContent = 'Saving...';

    google.script.run
      .withSuccessHandler(response => {
        showLoader(false);
        if (response.success) {
          button.textContent = 'Saved!';
          row.style.backgroundColor = '#dff0d8';
          // If status was changed, update the UI to reflect it permanently
          if (details.newStatus) {
            row.querySelector('.status-cell').innerHTML = `<span>${details.newStatus}</span>`;
          }
          setTimeout(() => {
            button.disabled = false;
            button.textContent = 'Save';
            row.style.backgroundColor = '';
          }, 2000);
        } else {
          handleError(new Error(response.message));
          button.disabled = false;
          button.textContent = 'Save';
        }
      })
      .withFailureHandler(err => {
        handleError(err);
        button.disabled = false;
        button.textContent = 'Save';
      })
      .updateUserDetailsByAdmin(userEmail, details, state.currentUser);
  }

  function showUserManagement() {
    showLoader(true);
    google.script.run
      .withSuccessHandler(users => {
        showLoader(false);
        renderUserManagementTable(users);
        switchView('user-management-view');
      })
      .withFailureHandler(handleError)
      .getUsersForAdmin(state.currentUser);
  }

  function renderUserManagementTable(users) {
    const container = document.getElementById('user-table-container');
    if (!users || users.length === 0) {
      container.innerHTML = '<p>No users found.</p>';
      return;
    }

    let tableHtml = '<table class="results-table"><thead><tr>';
    const headers = ['Full Name', 'Email', 'Role', 'Area', 'Status', 'Action'];
    headers.forEach(h => tableHtml += `<th>${h}</th>`);
    tableHtml += '</tr></thead><tbody>';

    users.forEach(user => {
      tableHtml += `<tr data-user-email="${user.email}">
        <td>${user.fullName}</td>
        <td>${user.email}</td>
        <td>${user.role}</td>
        <td>${user.areaName}</td>
        <td><span class="status-cell">${user.approvalStatus}</span></td>
        <td class="action-cell">`;

      if (user.approvalStatus === 'Pending') {
        tableHtml += `<button class="btn btn-primary approve-btn">Approve</button>
                      <button class="btn btn-secondary reject-btn">Reject</button>`;
      } else {
        tableHtml += `<span>-</span>`;
      }
      
      tableHtml += `</td></tr>`;
    });

    container.innerHTML = tableHtml + '</tbody></table>';
    
    // Add event listeners to the new buttons
    document.querySelectorAll('.approve-btn').forEach(btn => btn.addEventListener('click', handleUserApproval));
    document.querySelectorAll('.reject-btn').forEach(btn => btn.addEventListener('click', handleUserApproval));
  }

  function handleUserApproval(event) {
    const button = event.target;
    const row = button.closest('tr');
    const userEmail = row.dataset.userEmail;
    const newStatus = button.classList.contains('approve-btn') ? 'Approved' : 'Rejected';

    showLoader(true);
    button.disabled = true;

    google.script.run
      .withSuccessHandler(response => {
        showLoader(false);
        if (response.success) {
          alert(response.message);
          // Update the UI dynamically
          row.querySelector('.status-cell').textContent = newStatus;
          row.querySelector('.action-cell').innerHTML = `<span>-</span>`;
        } else {
          handleError(new Error(response.message));
          button.disabled = false;
        }
      })
      .withFailureHandler(err => {
        handleError(err);
        button.disabled = false;
      })
      .updateUserApprovalStatus(userEmail, newStatus, state.currentUser);
  }

  // --- COLUMN RESIZING LOGIC ---
  function makeTableResizable(table) {
      const headers = table.querySelectorAll('th');
      headers.forEach(header => {
          const resizer = document.createElement('div');
          resizer.className = 'resizer';
          header.appendChild(resizer);
          addResizerLogic(resizer, header);
      });
  }

  function addResizerLogic(resizer, header) {
      let x = 0;
      let w = 0;

      const mouseDownHandler = function(e) {
          x = e.clientX;
          const styles = window.getComputedStyle(header);
          w = parseInt(styles.width, 10);

          document.addEventListener('mousemove', mouseMoveHandler);
          document.addEventListener('mouseup', mouseUpHandler);
          resizer.classList.add('resizing');
      };

      const mouseMoveHandler = function(e) {
          const dx = e.clientX - x;
          header.style.width = `${w + dx}px`;
      };

      const mouseUpHandler = function() {
          document.removeEventListener('mousemove', mouseMoveHandler);
          document.removeEventListener('mouseup', mouseUpHandler);
          resizer.classList.remove('resizing');
      };

      resizer.addEventListener('mousedown', mouseDownHandler);
  }

  // --- TABBING LOGIC ---
  function handleTabSwitch(event) {
    if (!event.target.classList.contains('tab-link')) return;

    const nav = event.target.closest('.tab-nav');
    const tabContainer = nav.nextElementSibling.parentNode; // The parent element holding all tab content for this nav

    const tabLinks = nav.querySelectorAll('.tab-link');
    const tabContents = tabContainer.querySelectorAll('.tab-content');
    const targetTabId = event.target.dataset.tab;

    tabLinks.forEach(link => link.classList.remove('active'));
    tabContents.forEach(content => content.classList.remove('active'));

    event.target.classList.add('active');
    const targetContent = document.getElementById(targetTabId);
    if(targetContent) {
      targetContent.classList.add('active');
    }

    // Initialize directive view when tab is clicked
    if (targetTabId === 'bdm-directive-tab') {
      initializeDirectiveView();
    }
  }

function loadMySubmissions() {
    const container = document.getElementById('cl-submitted-container');
    container.innerHTML = '<p>Loading your submissions...</p>';
    
    google.script.run
      .withSuccessHandler(results => {
        state.mySubmissions = results; // Store results in state
        renderMySubmissions(); // Render the table from state
      })
      .withFailureHandler(err => {
        container.innerHTML = '<p class="error-message">Could not load submissions.</p>';
        handleError(err);
      })
      .getSubmittedByUser(state.currentUser);
  }

function renderClSearchResults(results) {
    const container = document.getElementById('cl-search-results-container');
    if (!results || results.length === 0) {
      container.innerHTML = '<p>No matching transactions found.</p>';
      return;
    }

    // Define the full, detailed, read-only list of columns for the CL view
    const displayHeaders = [
        'ACTION', // Added for consistency, though it will be empty here
        'BATCH_NO', 'TRANSACTION_ID', 'DATE_SUBMITTED', 'SUBMITTED_BY', 'HH_ID_NO',
        'GRANTEE_NAME', 'ENTRY_ID_NO', 'MEMBER_NAME', 'CASE_MANAGER', 'UPDATE_TYPE',
        'REQUIREMENTS_STATUS', 'NEW_VALUE', 'ATTACHMENTS', 'VALIDATION', 'RECOMMENDATION',
        'CURRENT_STATUS', 'STATUS_CHANGED_BY', 'DATE_STATUS_CHANGED', 'REMARKS'
    ];
    
    let tableHtml = '<table class="results-table"><thead><tr>';
    // Create table headers based on our defined list
    displayHeaders.forEach(header => {
      const formattedHeader = header.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
      tableHtml += `<th>${formattedHeader}</th>`;
    });
    tableHtml += '</tr></thead><tbody>';

    // Create a table row for each result
    results.forEach(row => {
      tableHtml += `<tr>`;
      // Iterate through our defined headers to ensure the correct cell order and content
      displayHeaders.forEach(header => {
        if (header === 'ACTION') {
            tableHtml += `<td>-</td>`; // No actions in general search
            return;
        }

        const value = row[header];
        let displayValue = value === null || value === undefined ? '' : value;

        // Robust date formatting for any date column
        if (header.toLowerCase().includes('date') && displayValue) {
          const d = new Date(displayValue);
          if (d instanceof Date && !isNaN(d.getTime())) {
            displayValue = d.toLocaleString();
          }
        }
        
        tableHtml += `<td>${displayValue}</td>`;
      });
      tableHtml += `</tr>`;
    });

    container.innerHTML = tableHtml + '</tbody></table>';
  }

function handleMySubmissionsActions(event) {
    const button = event.target;
    if (button.tagName !== 'BUTTON') return;

    if (button.classList.contains('delete-btn')) {
        if (confirm('Are you sure you want to permanently delete this transaction? This cannot be undone.')) {
            const transactionId = button.dataset.transactionId;
            showLoader(true);
            google.script.run
                .withSuccessHandler(response => {
                    showLoader(false);
                    alert(response.message);
                    if (response.success) {
                        loadMySubmissions(); // Refresh the list
                    }
                })
                .withFailureHandler(handleError)
                .deleteTransactionByCL(transactionId, state.currentUser);
        }
    } else if (button.classList.contains('edit-btn')) {
        toggleRowToEdit(button);
    } else if (button.classList.contains('save-cl-btn')) {
        saveClEditedRow(button);
    } else if (button.classList.contains('cancel-cl-btn')) {
        // Just re-render the table from the state to cancel changes
        renderMySubmissions();
    }
}

function saveClEditedRow(saveButton) {
    const row = saveButton.closest('tr');
    const transactionId = saveButton.dataset.transactionId;

    // Construct the data object from the input fields in the row
    const transactionData = {
        TRANSACTION_ID: transactionId,
        HH_ID_NO: row.querySelector('.cl-edit-hh-id').value,
        GRANTEE_NAME: row.querySelector('.cl-edit-grantee-name').value,
        ENTRY_ID_NO: row.querySelector('.cl-edit-entry-id').value,
        MEMBER_NAME: row.querySelector('.cl-edit-member-name').value,
        UPDATE_TYPE: row.querySelector('.cl-edit-update-type').value,
        NEW_VALUE: row.querySelector('.cl-edit-new-value').value,
        REQUIREMENTS_STATUS: row.querySelector('.cl-edit-req-status').value,
        ATTACHMENTS: row.querySelector('.cl-edit-attachments').value,
        VALIDATION: row.querySelector('.cl-edit-validation').value,
        RECOMMENDATION: row.querySelector('.cl-edit-recommendation').value
    };

    showLoader(true);
    google.script.run
        .withSuccessHandler(response => {
            showLoader(false);
            alert(response.message);
            if (response.success) {
                loadMySubmissions(); // Refresh the list from the server
            }
        })
        .withFailureHandler(handleError)
        .updateTransactionByCL(transactionData, state.currentUser);
}

function toggleRowToEdit(editButton) {
    const tr = editButton.closest('tr');
    const rowIndex = tr.dataset.rowIndex;
    const rowData = state.mySubmissions[rowIndex];

    // These are the fields that can be edited by the CL user.
    // The order must match the 'headers' array in renderMySubmissions.
    const editableCells = {
        3: { value: rowData.HH_ID_NO, className: 'cl-edit-hh-id' },
        4: { value: rowData.GRANTEE_NAME, className: 'cl-edit-grantee-name' },
        5: { value: rowData.MEMBER_NAME, className: 'cl-edit-member-name' },
        6: { value: rowData.ENTRY_ID_NO, className: 'cl-edit-entry-id' },
        7: { value: rowData.UPDATE_TYPE, className: 'cl-edit-update-type', type: 'select', options: state.dropdownOptions.updateTypeTemplates.map(t => t.updateType) },
        8: { value: rowData.NEW_VALUE, className: 'cl-edit-new-value' },
        9: { value: rowData.REQUIREMENTS_STATUS, className: 'cl-edit-req-status', type: 'select', options: ['Complete', 'Incomplete', 'N/A'] },
        10: { value: rowData.ATTACHMENTS, className: 'cl-edit-attachments' },
        11: { value: rowData.VALIDATION, className: 'cl-edit-validation' },
        12: { value: rowData.RECOMMENDATION, className: 'cl-edit-recommendation' }
    };

    // Replace cell content with inputs/selects
    Object.keys(editableCells).forEach(cellIndex => {
        const cell = tr.cells[cellIndex];
        const config = editableCells[cellIndex];
        if (config.type === 'select') {
            cell.innerHTML = `<select class="${config.className}">${generateSelectOptions(config.options, config.value, false)}</select>`;
        } else {
            cell.innerHTML = `<input type="text" class="${config.className}" value="${config.value || ''}">`;
        }
    });

    // Update the action cell
    tr.cells[0].innerHTML = `
        <button class="btn btn-primary save-cl-btn" data-transaction-id="${rowData.TRANSACTION_ID}">Save</button>
        <button class="btn btn-secondary cancel-cl-btn">Cancel</button>
    `;
}

  // A generic function to render read-only results for the "My Submissions" tab
function renderMySubmissions() {
      const container = document.getElementById('cl-submitted-container');
      const results = state.mySubmissions;

      if (!results || results.length === 0) {
        container.innerHTML = '<p>You have not submitted any transactions yet.</p>';
        return;
      }
      
      // Define headers for the "My Submissions" view
      const headers = [
          'ACTION',
          'CURRENT_STATUS',
          'TRANSACTION_ID',
          'HH_ID_NO',
          'GRANTEE_NAME',
          'MEMBER_NAME',
          'ENTRY_ID_NO',
          'UPDATE_TYPE',
          'NEW_VALUE',
          'REQUIREMENTS_STATUS',
          'ATTACHMENTS',
          'VALIDATION',
          'RECOMMENDATION',
          'REMARKS',
          'DATE_SUBMITTED',
      ];
      
      let tableHtml = `<table class="results-table" id="my-submissions-table"><thead><tr>`;
      headers.forEach(h => {
        tableHtml += `<th>${h.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}</th>`;
      });
      tableHtml += '</tr></thead><tbody>';

      results.forEach((row, index) => {
          // Add a data attribute to the row to easily find its data later
          tableHtml += `<tr data-row-index="${index}">`;
          
          headers.forEach(header => {
            if (header === 'ACTION') {
              if (row.CURRENT_STATUS === 'Submitted') {
                tableHtml += `
                  <td class="action-cell" style="white-space: nowrap;">
                    <button class="btn btn-secondary edit-btn" data-transaction-id="${row.TRANSACTION_ID}">Edit</button>
                    <button class="btn btn-danger delete-btn" data-transaction-id="${row.TRANSACTION_ID}">Delete</button>
                  </td>`;
              } else {
                tableHtml += `<td><span style="color: #777;">Processed</span></td>`;
              }
              return; // Continue to next header
            }

            const value = row[header];
            let displayValue = value === null || value === undefined ? '' : value;

            if (header.includes('DATE') && displayValue) {
              const d = new Date(displayValue);
              if (d instanceof Date && !isNaN(d.getTime())) {
                displayValue = d.toLocaleString();
              }
            }
            if (header === 'CURRENT_STATUS') {
              displayValue = `<span style="font-weight: bold;">${displayValue}</span>`;
            }
            tableHtml += `<td>${displayValue}</td>`;
          });
          tableHtml += `</tr>`;
      });
      container.innerHTML = tableHtml + '</tbody></table>';

      const table = document.getElementById('my-submissions-table');
      if (table) {
        makeTableResizable(table);
      }
  }

 // --- DUPLICATION LOGIC ---

  /**
   * Re-calculates and updates the Transaction ID for every row in the table.
   * Ensures transaction IDs are always sequential based on their current row order.
   */
  function reIndexRows() {
    const tableBody = document.getElementById('transaction-table-body');
    if (!tableBody) return;

    const batchNo = document.getElementById('batch-id-display').textContent;
    const allRows = tableBody.querySelectorAll('tr');
    allRows.forEach((row, index) => {
      const sequence = (index + 1).toString().padStart(2, '0');
      const newTransactionId = `${batchNo}-${sequence}`;
      const idInput = row.querySelector('.transaction-id');
      if (idInput) {
        idInput.value = newTransactionId;
      }
    });
  }

  /**
   * Helper function to perform the core row duplication.
   * It clones the row's HTML and re-attaches all necessary event listeners.
   * @param {HTMLTableRowElement} sourceRow The row to duplicate.
   * @returns {HTMLTableRowElement} The newly created and inserted row.
   */
  function _createAndReplicateRow(sourceRow) {
    const tableBody = document.getElementById('transaction-table-body');
    const newRow = tableBody.insertRow(sourceRow.rowIndex); // Insert just below the source
    newRow.innerHTML = sourceRow.innerHTML; // Copy the structure

    // Re-attach all event listeners since innerHTML does not copy them
    newRow.querySelector('.remove-row-btn').addEventListener('click', (e) => removeTransactionRow(e.target));
    newRow.querySelector('.hh-id').addEventListener('blur', handleHhIdBlurForRow);
    newRow.querySelector('.member-name').addEventListener('change', handleMemberSelection);
    newRow.querySelector('.update-type').addEventListener('change', handleUpdateTypeChange);
    newRow.querySelector('.hh-duplicate').addEventListener('click', duplicateRowByHousehold);
    newRow.querySelector('.member-duplicate').addEventListener('click', duplicateRowByMember);
    
    // BUG FIX: Re-attach the auto-resize listeners for all textareas in the newly created row.
    newRow.querySelectorAll('textarea').forEach(textarea => {
      textarea.addEventListener('input', () => autoResizeTextarea(textarea));
    });

    return newRow;
  }

  /**
   * Creates a new row with the same Household ID, then clears all other fields.
   */
  function duplicateRowByHousehold(event) {
    const sourceRow = event.target.closest('tr');
    const sourceHhId = sourceRow.querySelector('.hh-id').value;

    if (!sourceHhId) {
      alert('Please enter a Household ID in the source row first.');
      return;
    }
    
    const newRow = _createAndReplicateRow(sourceRow);

    // Set the HH ID value correctly and clear/reset everything else
    newRow.querySelector('.hh-id').value = sourceHhId;
    newRow.querySelector('.grantee-name').value = '';
    newRow.querySelector('.entry-id').value = '';
    newRow.querySelector('.member-name').innerHTML = '<option value="">-- Enter HH ID First --</option>';
    newRow.querySelector('.member-name').disabled = true;
    newRow.querySelector('.update-type').selectedIndex = 0;
    newRow.querySelector('.new-value').value = '';
    newRow.querySelector('.req-status').selectedIndex = 0;
    newRow.querySelector('.attachments').value = '';
    newRow.querySelector('.validation').value = '';
    newRow.querySelector('.recommendation').value = '';


    // Re-index all rows to assign a new, correct transaction ID
    reIndexRows();

    // Trigger the data fetch for the duplicated HH ID
    newRow.querySelector('.hh-id').dispatchEvent(new Event('blur'));
  }

  /**
   * Creates a new row with the same household and member info, clearing only the transaction-specific details.
   */
  function duplicateRowByMember(event) {
    const sourceRow = event.target.closest('tr');
    const sourceHhId = sourceRow.querySelector('.hh-id').value;
    const sourceMemberName = sourceRow.querySelector('.member-name').value;

    if (!sourceHhId || !sourceMemberName) {
      alert('Please select a Household ID and a Member Name in the source row first.');
      return;
    }
    
    const newRow = _createAndReplicateRow(sourceRow);
    
    // Copy all the household and member-specific data
    newRow.querySelector('.hh-id').value = sourceHhId;
    newRow.querySelector('.grantee-name').value = sourceRow.querySelector('.grantee-name').value;
    newRow.querySelector('.entry-id').value = sourceRow.querySelector('.entry-id').value;
    
    // Copy the household data context and re-populate the dropdown
    newRow.dataset.householdData = sourceRow.dataset.householdData;
    const memberSelect = newRow.querySelector('.member-name');
    if (sourceRow.dataset.householdData) {
      memberSelect.innerHTML = sourceRow.querySelector('.member-name').innerHTML;
      memberSelect.value = sourceMemberName; // Re-select the correct member
      memberSelect.disabled = false;
    }

    // Clear only the transaction-specific fields
    newRow.querySelector('.update-type').selectedIndex = 0;
    newRow.querySelector('.new-value').value = '';
    newRow.querySelector('.req-status').selectedIndex = 0;
    newRow.querySelector('.attachments').value = '';
    newRow.querySelector('.validation').value = '';
    newRow.querySelector('.recommendation').value = '';

    // Re-index all rows to assign a new, correct transaction ID
    reIndexRows();
  }

  // --- REGIONAL DIRECTIVE LOGIC ---

/**
 * Initializes the directive view by fetching a new ID and rendering the creator form.
 * This function now ALWAYS rebuilds the form to ensure it's fresh.
 */
function initializeDirectiveView() {
  const container = document.getElementById('directive-creator-container');
  
  // This function is now designed to run every time, so we don't check if the form exists.
  // We start by showing a loading message to indicate a refresh.
  container.innerHTML = '<p>Loading directive creator...</p>';
  showLoader(true);

  google.script.run
    .withSuccessHandler(newDirectiveId => {
      showLoader(false);
      renderDirectiveCreator(newDirectiveId);
    })
    .withFailureHandler(err => {
      showLoader(false);
      container.innerHTML = `<p class="error-message">Could not initialize directive creator: ${err.message}</p>`;
    })
    .generateNewDirectiveId(state.currentUser);
}

/**
 * Renders the HTML form for creating a new directive.
 * @param {string} directiveId The new ID to use for the directive.
 */
function renderDirectiveCreator(directiveId) {
  const container = document.getElementById('directive-creator-container');
  const { directiveTypes, directiveStatuses, caseManagers } = state.dropdownOptions;
  
  container.innerHTML = `
    <h2>Create New Regional Directive</h2>
    <form id="directive-creator-form">
      <div class="form-grid">
        <div class="form-group">
          <label>Directive ID</label>
          <input type="text" id="dir-id" value="${directiveId}" readonly>
        </div>
        <div class="form-group">
          <label for="dir-hh-id">Household ID No.</label>
          <input type="text" id="dir-hh-id" required>
        </div>
        <div class="form-group">
          <label for="dir-grantee-name">Grantee Name</label>
          <input type="text" id="dir-grantee-name" required>
        </div>
        <div class="form-group">
          <label for="dir-entry-id">Entry ID</label>
          <input type="text" id="dir-entry-id">
        </div>
        <div class="form-group">
          <label for="dir-member-name">Member Name</label>
          <input type="text" id="dir-member-name">
        </div>
        <div class="form-group">
          <label for="dir-type">Directive Type</label>
          <select id="dir-type" required>${generateSelectOptions(directiveTypes, null, true)}</select>
        </div>
        <div class="form-group">
          <label for="dir-date-endorsed">Date Endorsed from Region</label>
          <input type="date" id="dir-date-endorsed" required>
        </div>
        <div class="form-group">
          <label for="dir-status">Directive Current Status</label>
          <select id="dir-status" required>${generateSelectOptions(directiveStatuses, null, true)}</select>
        </div>
        <div class="form-group">
          <label for="dir-case-manager">Case Manager</label>
          <select id="dir-case-manager" required>${generateSelectOptions(caseManagers, null, true)}</select>
        </div>
        <div class="form-group full-width">
          <label for="dir-details">Details</label>
          <textarea id="dir-details" rows="1"></textarea>
        </div>
        <div class="form-group full-width">
          <label for="dir-remarks">Remarks</label>
          <textarea id="dir-remarks" rows="1"></textarea>
        </div>
      </div>
      <div class="form-actions">
        <button type="submit" id="save-new-directive-btn" class="btn btn-primary" disabled>Save New Directive</button>
      </div>
    </form>
  `;

  // Attach a more robust listener to the form
  const form = document.getElementById('directive-creator-form');
  form.addEventListener('input', (event) => {
    // Enable save button logic
    const saveBtn = document.getElementById('save-new-directive-btn');
    saveBtn.disabled = false;
    saveBtn.classList.add('btn-actionable');
    saveBtn.classList.remove('btn-success');
    saveBtn.textContent = 'Save New Directive';

    // Auto-resize any textarea that triggered the input event
    if (event.target.tagName.toLowerCase() === 'textarea') {
      autoResizeTextarea(event.target);
    }
  });

  // Set initial size for textareas upon creation
  form.querySelectorAll('textarea').forEach(autoResizeTextarea);
}

/**
 * Handles actions within the directive creator form, primarily saving.
 * @param {Event} event The click event.
 */
function handleDirectiveCreatorActions(event) {
  if (event.target.id === 'save-new-directive-btn') {
    event.preventDefault();
    const button = event.target;
    const form = document.getElementById('directive-creator-form');
    if (!form.checkValidity()) {
      alert('Please fill out all required fields.');
      form.reportValidity();
      return;
    }

    const directiveData = {
      DIRECTIVE_ID: document.getElementById('dir-id').value,
      HOUSEHOLD_ID: document.getElementById('dir-hh-id').value,
      GRANTEE_NAME: document.getElementById('dir-grantee-name').value,
      ENTRY_ID: document.getElementById('dir-entry-id').value,
      MEMBER_NAME: document.getElementById('dir-member-name').value,
      DIRECTIVE_TYPE: document.getElementById('dir-type').value,
      DATE_ENDORSED: document.getElementById('dir-date-endorsed').value,
      DETAILS: document.getElementById('dir-details').value,
      CURRENT_STATUS: document.getElementById('dir-status').value,
      CASE_MANAGER: document.getElementById('dir-case-manager').value, // ADDED
      REMARKS: document.getElementById('dir-remarks').value
    };

    showLoader(true);
    button.disabled = true;
    button.textContent = 'Saving...';
    
    google.script.run
      .withSuccessHandler(response => {
        showLoader(false);
        if (response.success) {
          button.classList.remove('btn-actionable');
          button.classList.add('btn-success');
          button.textContent = 'Saved Successfully!';
          alert('Directive saved successfully.');
          // Reset form for the next entry
          initializeDirectiveView(); 
        } else {
          button.disabled = false;
          button.classList.add('btn-actionable');
          button.textContent = 'Save New Directive';
          handleError(new Error('Server failed to save directive.'));
        }
      })
      .withFailureHandler(err => {
        showLoader(false);
        button.disabled = false;
        button.classList.add('btn-actionable');
        button.textContent = 'Save New Directive';
        handleError(err);
      })
      .saveOrUpdateDirective(directiveData, state.currentUser);
  }
}

/**
 * Handles the search form submission for directives.
 * @param {Event} event The form submission event.
 */
function handleDirectiveSearch(event) {
  event.preventDefault();
  const hhId = document.getElementById('directive-search-input').value;
  if (!hhId) {
    alert('Please enter a Household ID to search.');
    return;
  }
  fetchAndRenderDirectives({ type: 'hhId', value: hhId });
}

/**
 * Fetches directives from the server and renders them in the list.
 * @param {object} criteria The search criteria for the server.
 */
function fetchAndRenderDirectives(criteria) {
  const container = document.getElementById('directive-list-results');
  container.innerHTML = '<p>Loading directives...</p>';
  showLoader(true);

  google.script.run
    .withSuccessHandler(directives => {
      showLoader(false);
      renderDirectivesList(directives);
    })
    .withFailureHandler(err => {
      showLoader(false);
      container.innerHTML = `<p class="error-message">Could not load directives: ${err.message}</p>`;
    })
    .getDirectives(criteria);
}

/**
 * Renders the list of directives in an editable table.
 * @param {Array<object>} directives The array of directive objects from the server.
 */
function renderDirectivesList(directives) {
  const container = document.getElementById('directive-list-results');
  if (!directives || directives.length === 0) {
    container.innerHTML = '<p>No directives found.</p>';
    return;
  }

  const { directiveTypes, directiveStatuses, caseManagers } = state.dropdownOptions;
  const headers = ['HH ID', 'Grantee Name', 'Member Name', 'Directive Type', 'Date Endorsed', 'Details', 'Current Status', 'Case Manager', 'Remarks', "Day's Lapsed", 'Action'];
  
  let tableHtml = '<table class="results-table"><thead><tr>';
  headers.forEach(h => tableHtml += `<th>${h}</th>`);
  tableHtml += '</tr></thead><tbody>';

  directives.forEach(dir => {
    const endorsedDate = new Date(dir.DATE_ENDORSED).toISOString().split('T')[0];
    let daysLapsedClass = 'days-lapsed-green';
    if (dir.DAYS_LAPSED >= 20) daysLapsedClass = 'days-lapsed-red';
    else if (dir.DAYS_LAPSED >= 10) daysLapsedClass = 'days-lapsed-yellow';
    
    tableHtml += `<tr data-directive-id="${dir.DIRECTIVE_ID}">
      <td><input type="text" class="dir-list-hh-id" value="${dir.HOUSEHOLD_ID || ''}"></td>
      <td><input type="text" class="dir-list-grantee-name" value="${dir.GRANTEE_NAME || ''}"></td>
      <td><input type="text" class="dir-list-member-name" value="${dir.MEMBER_NAME || ''}"></td>
      <td><select class="dir-list-type">${generateSelectOptions(directiveTypes, dir.DIRECTIVE_TYPE, false)}</select></td>
      <td><input type="date" class="dir-list-date-endorsed" value="${endorsedDate}"></td>
      <td><textarea class="dir-list-details" rows="1">${dir.DETAILS || ''}</textarea></td>
      <td><select class="dir-list-status">${generateSelectOptions(directiveStatuses, dir.CURRENT_STATUS, false)}</select></td>
      <td><select class="dir-list-case-manager">${generateSelectOptions(caseManagers, dir.CASE_MANAGER, false)}</select></td>
      <td><textarea class="dir-list-remarks" rows="1">${dir.REMARKS || ''}</textarea></td>
      <td class="${daysLapsedClass}">${dir.DAYS_LAPSED}</td>
      <td><button class="btn btn-primary update-directive-btn" disabled>Save</button></td>
    </tr>`;
  });

  container.innerHTML = tableHtml + '</tbody></table>';

  // Attach change listeners and resize textareas
  container.querySelectorAll('tr[data-directive-id]').forEach(row => {
    row.addEventListener('input', (event) => {
      const saveBtn = row.querySelector('.update-directive-btn');
      saveBtn.disabled = false;
      saveBtn.classList.remove('btn-success');
      saveBtn.classList.add('btn-actionable');
      saveBtn.textContent = 'Save';
    });
    row.querySelectorAll('textarea').forEach(autoResizeTextarea);
  });
}

/**
 * Handles actions in the directive list table, specifically updating a row.
 * @param {Event} event The click event.
 */
function handleDirectiveListActions(event) {
  if (event.target.classList.contains('update-directive-btn')) {
    event.preventDefault();
    const button = event.target;
    const row = button.closest('tr');
    const directiveId = row.dataset.directiveId;

    const directiveData = {
      DIRECTIVE_ID: directiveId,
      HOUSEHOLD_ID: row.querySelector('.dir-list-hh-id').value,
      GRANTEE_NAME: row.querySelector('.dir-list-grantee-name').value,
      MEMBER_NAME: row.querySelector('.dir-list-member-name').value,
      DIRECTIVE_TYPE: row.querySelector('.dir-list-type').value,
      DATE_ENDORSED: row.querySelector('.dir-list-date-endorsed').value,
      DETAILS: row.querySelector('.dir-list-details').value,
      CURRENT_STATUS: row.querySelector('.dir-list-status').value,
      CASE_MANAGER: row.querySelector('.dir-list-case-manager').value, // ADDED
      REMARKS: row.querySelector('.dir-list-remarks').value
    };

    showLoader(true);
    button.disabled = true;
    button.textContent = 'Saving...';
    
    google.script.run
      .withSuccessHandler(response => {
        showLoader(false);
        if (response.success) {
          button.classList.remove('btn-actionable');
          button.classList.add('btn-success');
          button.textContent = 'Saved!';
          // Re-disable after a delay
          setTimeout(() => {
            button.disabled = true;
            button.classList.remove('btn-success');
            button.textContent = 'Save';
          }, 2500);
        } else {
          handleError(new Error('Server failed to update directive.'));
          button.disabled = false;
          button.classList.add('btn-actionable');
          button.textContent = 'Save';
        }
      })
      .withFailureHandler(err => {
        showLoader(false);
        handleError(err);
        button.disabled = false;
        button.classList.add('btn-actionable');
        button.textContent = 'Save';
      })
      .saveOrUpdateDirective(directiveData, state.currentUser);
  }
}
</script>
